"use server"

import dbConnect from "@/lib/db"
import FeeTransaction from "@/models/FeeTransaction"
import ClassFee from "@/models/ClassFee"
import Student from "@/models/Student"
import Class from "@/models/Class"
import { revalidatePath } from "next/cache"
import { z } from "zod"

const collectFeeSchema = z.object({
  studentId: z.string().min(1, "Student is required"),
  feeType: z.string().min(1, "Fee type is required"), // Changed from enum to string to support dynamic types
  amount: z.number().min(1, "Amount must be positive"),
  months: z.array(z.number()).optional(),
  year: z.number().min(2000),
  examType: z.string().optional(),
  title: z.string().optional(),
  remarks: z.string().optional(),
})

export async function getStudentFeeDetails(studentId: string) {
  await dbConnect();
  const student = await Student.findById(studentId).populate('classId').lean();
  if (!student) return null;

  // Get current active fees for the class
  const fees = await ClassFee.find({
    classId: student.classId._id,
    isActive: true
  }).lean();

  // Get exam list from class
  const classData = await Class.findById(student.classId._id).lean();

  return {
    classId: student.classId._id.toString(),
    className: student.classId.name,
    exams: classData.exams || [],
    fees: fees.map(f => ({
        type: f.type,
        amount: f.amount,
        id: f._id.toString()
    }))
  };
}

export async function collectFee(data: z.infer<typeof collectFeeSchema>, userId: string) {
  try {
    collectFeeSchema.parse(data);
    await dbConnect();

    const monthsToProcess = data.months ? data.months.map(m => m + 1) : [];
    
    // Check for existing payments based on fee type
    if (data.feeType === 'monthly' && monthsToProcess.length > 0) {
      for (const m of monthsToProcess) {
        const existing = await FeeTransaction.findOne({
          studentId: data.studentId,
          feeType: 'monthly',
          month: m,
          year: data.year,
          status: { $ne: 'rejected' }
        });
        if (existing) {
          return {
            success: false,
            error: `Fee for month ${m}/${data.year} already paid/pending.`
          };
        }
      }
    } else if (data.feeType === 'examination') {
      const existing = await FeeTransaction.findOne({
        studentId: data.studentId,
        feeType: 'examination',
        examType: data.examType,
        year: data.year,
        status: { $ne: 'rejected' }
      });
      if (existing) {
        return { success: false, error: `Fee for ${data.examType} ${data.year} already paid/pending.` };
      }
    } else if (['admission', 'admissionFees', 'registrationFees'].includes(data.feeType)) {
        // One-time fees per year or once per admission?
        // Usually admission is once, registration is annual.
        // Assuming annual checks for now based on 'year' field.
      const existing = await FeeTransaction.findOne({
        studentId: data.studentId,
        feeType: data.feeType,
        year: data.year,
        status: { $ne: 'rejected' }
      });
      if (existing) {
        return { success: false, error: `${data.feeType} for ${data.year} already paid/pending.` };
      }
    }

    // Process payment
    if (data.feeType === 'monthly' && monthsToProcess.length > 0) {
      const amountPerMonth = data.amount / monthsToProcess.length;

      // Create a transaction for each month
      for (const m of monthsToProcess) {
        const receiptNumber = `RCP-${Date.now()}-${m}`;

        await FeeTransaction.create({
          receiptNumber,
          studentId: data.studentId,
          feeType: 'monthly',
          amount: amountPerMonth,
          month: m,
          year: data.year,
          remarks: data.remarks,
          collectedBy: userId,
          status: 'pending',
          transactionDate: new Date(),
        });
        
        // Small delay to ensure unique receipt numbers if generated by timestamp
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      const student = await Student.findById(data.studentId).populate('classId', 'name').lean();

      revalidatePath("/fees/collect");
      return {
        success: true,
        receiptNumber: `RCP-${Date.now()}`, // Group receipt number? Or just last one?
        // Returning a generic receipt number for the batch
        receiptData: {
          studentName: student?.name || '',
          studentRegNo: student?.registrationNumber || '',
          className: student?.classId?.name || '',
          feeType: data.feeType,
          months: monthsToProcess,
          year: data.year,
          amount: data.amount,
          title: data.title,
          examType: data.examType
        }
      };

    } else {
      // Single transaction
      const receiptNumber = `RCP-${Date.now()}`;

      await FeeTransaction.create({
        receiptNumber,
        studentId: data.studentId,
        feeType: data.feeType,
        amount: data.amount,
        month: undefined,
        year: data.year,
        examType: data.examType,
        remarks: data.remarks,
        collectedBy: userId,
        status: 'pending',
        transactionDate: new Date(),
        title: data.title // Store custom title for 'other' or specific fees
      });

      const student = await Student.findById(data.studentId).populate('classId', 'name').lean();

      revalidatePath("/fees/collect");
      return {
        success: true,
        receiptNumber,
        receiptData: {
          studentName: student?.name || '',
          studentRegNo: student?.registrationNumber || '',
          className: student?.classId?.name || '',
          feeType: data.feeType,
          year: data.year,
          examType: data.examType,
          title: data.title,
          amount: data.amount
        }
      };
    }
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : "An unknown error occurred";
    return { success: false, error: message };
  }
}
